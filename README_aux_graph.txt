Modification history:

stage 1: adapt the library to an RWTA algorithm
for QKD secured optical network

1. created parameters loading scripts
  （run_quick_sim）

2. added auxgraph_demo_net network topo

3. added weight to the adjacency matrix
    to achieve this:
    changed the adjacency matrix data type
    from bool to np.float32;
    added a third parameter in get_edges
    for the auxgraph network;
    changed logics in matrix filling-in
    so that the weight can be stored;
    changed some plotting strategies;

4. added a debug function for the dijkstra
   convenient for inspecting if dijkstra is 
   working alright.
   As well helpful for auxgraph construction

5. no time-sliding window is used in this paper
   it means if a time slot is occupied, then
   find another time slot using first fit
   There are 4 wavelenghts for Qchs according 
   to the paper.
   According to this strategy and possion arrival-
   settings in the article (leave rate = 0.004/deta-t)
   holding time = 10 delta-t (temporarily not considering update),
   modified the possion arrival formula.
   Adaption for network initialzation, currently initalised 
   initial holding time to rand int 0-10.(To avoid uneven distribution)

6. originally, source and destination nodes are network attributes,
   and are static. Here, the network attribute s and d is abandoned,
   and changed to dynamic attribute attached to each request, so as 
   to stay in line with the paper(and the reality). 
   modification to rwa.py and sim.py are conducted accordingly
   there is a bug where the bp starts from 50% at even 1 erlang,
   It is mysteriously fixed, I don't know why

7. some modification are done to io module and an extra attribute
   load_min and load_step is added in order to conduct experiment 
   in specific load(traffic) range

stage 2: Adding FB-RWTA realisation

8. fine tune to the possion arrival, enabling multiple arrival within 1 
   timeslot, and the RWTA baseline result is close to the result in
   the paper.

9. added aux_graph_d2 class, deemed as a net topo, with additional 2
   properties: aux_edge and aux_path. these two are constructed based on 
   dijkstra performed on every node as source node, and the rest as destination
   node. adjacency matrix is normally initialised in network.py and
   auxiliary graph edges are added to adjacency matrix in children class
   auxgraph_aux_d2

10. added a function: _expand_aux_route to the rwa module, it identifies
    whether a route contains virtual links by applying an fixed-length sliding
    window to the route returned by dijkstra. If it does contain virtual links,
    then replace the virtual link by its actual physical link using the aux_path
    dictionary acquired through virtual_adjacency2physical_path(). and if there is
    indeed an virtual path, return a true flag variabl called contains_virtual_path.
    the physical link is used afterwards for wave and time slot allocation.

11. added a new param to lightpath object: _contains_virtual
    it is connected to the function _expand_aux_route in rwa module
    a True value is passed to it if rwa module detects the current 
    light path contains a virtual link.

12. added handler for the virtual path flag in PB_RWTA so that if a path
    contains virtual edge, the lightpath holding time be multiplied by TP
    which is 1.5 in this context

13. Reworked the whole simulator main loop to realize the update request
    feature. The simulator now adpots a minheap as a request manager and 
    utilizes an absolute clock to synchronize request time. There are some
    relevant flags to control the seperate processing for original request
    and update request generated by the respective original request. New 
    requests generation logics has also been modified: if request number 
    has not met the upper limit, an original request will generate another
    original request, which will be pushed into the heap. And only when an
    original request is allocated with resources successfully, update requests
    would be generated accordingly and pushed into the heap.

14. Bug fix: the original first fit doesn't work as it is supposed to. It
    looks for the first available wavelength, and do nothing if the subsequent
    links have no available wavelength, the allocation just fails. It is now
    modified to perform correctly.

15. Bug fix: After the major rework, the lightpath update logic needs to be placed at 
    the start of the simulator for correct time update.

16. Bug fix: there is a little hard-to-notice grammar bug when calculating the resource
    utilization rate. This is due to python generator characteristics. Fixed by 
    first using a list to store the acquired lightpath.links and perform calculations
    on the list. This results in more accurate resource utilization results.

stage3: adding PB_RWTA

17. PB_RWTA firstly needs mapping from auxgraph(i) to auxgraph(i-1). But in this
    case aux_graph_d1 is just the physical network. So no modification needs to be
    done to the aux_graph network topo and data structures.

18. Added detection for resource usage and compare with the resource threshold SR.
    If usage exceeds SR then make holding time return to 10 slots, this means the
    bypassing process is stopped, and regular relay process is working. If usage
    does not exceed SR, then keep the bypassing behavior.

Fine tune log:
19. First locate the problem in first-fit. In this paper's context using different
    wavelength after passing a relay node is permitted. So the first-fit strategy
    is changed accordingly.

20. tried many kinds of possion arrival - most successful using a round method with 0.2 bias

21. Fine tuning inspiration: tried many pb resource conditions: either too close to base or
    too close to FB -> Not pb problem -> could only be resource allocation -> has nothing to do
    with dijkstra -> first fit issues -> considering the relay process, it first fit might be able
    to use different wavelength accrossing relays -> two kinds of possibility when bypassing: same
    wavelength(as the original one) or different wavelength -> turns out that different wavelength 
    method has closer result to paper.

22. potential bug: don't know how will dijkstra choose the route when weights are same(when bypassing)
    from test results it chooses ones with less hops (which is expected behavior). Some defensive considering
    are to be made. By minusing a very small number on the weight of the aux_edge. Correct behavior is guaranteed.
    (But actually the result is the same). So eventually nothing is modified.

Modification: adding actual fallback layer of auxgraph. Now there are 2 auxgraphs, d1 and aux_graph_d2

23. SR1 is 0.4, SR2 is 0.7. TP2 = 1.5, TP1 = 1.25, TP0 = 1.

24. Added auxgraph_aux_d1 whose threshold is 33.0. added logics in auxgraph_aux_d2 to map d1 to d2, in
    addition to mapping physical to d2. 

25. Added handler in simulator, if traffic is between 0.4 and 0.7, check whether d2 virtual routes mapped
    to d1 contains d1 virtual routes. If contains d1 virtual route, that means nodes can be bypassed in d1.
    If not, that means allocation shall be using TP0.

QKP experiment stage

26. added qkp module to net.py, the container is qkp_pools: Dict[Tuple[int, int], int], the tuple stand for
    the node pair, i.e. the qkp between two nodes. The int is the number of keys stored in it. the '1'
    unit here stand for the number of keys that can be produced in one time slot. self._qkp_key_map and _normalize
    edge helps store the pairs of qkp and the reversed pair, so that any input can be correctly stored into the respective
    QKP.

27. A number of interfaces have been constructed to manipulate QKPs. add_qkp adds a certain amount of keys
    into a designated QKP, use_qkp combines checking and consuming process of a designated qkp together. Get_qkp
    returns the number of keys in one qkp. Record_bypass_saved_keys is used for passive QKP storage. It charges
    the QKP saved in a bypass process into the respective QKP, and generates a log in the mean time, so that the
    charging process can be traced. Get_qkp_log returns the qkp charging log constructed by Record_bypass_saved_keys.

28. In the simulator main module, the saved keys in a bypass is stored into the respective QKP.